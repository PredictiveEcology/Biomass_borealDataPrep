---
title: "Biomass_borealDataPrep"
author: "Yong Luo, Eliot McIntire, Ceres Barros, Alex Chubaty"
date: "24 September 2019, updated 26 Jul 2021"
output:
  html_document:
    keep_md: yes
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, results = "hold")
```

[![Gitter](https://badges.gitter.im/PredictiveEcology/LandR_Biomass.svg)](https://gitter.im/PredictiveEcology/LandR_Biomass?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)

# Overview

This module converts open datasets that are available for all of Canada's forests, into the input requirements for LandR Biomass, a forest landscape succession model derived from the Landis-II Biomass Succession Extension model (v3.2; hereafter LBSE). 
This has been designed and tested for some parts of the Western Boreal Forest. 

Specifically, it takes the stand biomass, stand age (defaulting to the kNN biomass/age maps), land-cover (Land Cover of Canada map by default) and ecological zonation maps of Canada (ecodistricts by default), as well as species specific % cover maps of Canada (defaulting to the kNN maps) and derives LandR Biomass parameter estimates from these data.
Species traits are taken from those used by Dominic Cyr for LANDIS-II simulations, with some exceptions (see below).

Keeping data preparation outside of the LandR `Biomass_core` module maintains the modularity of the LandR modules.

# Functioning

After downloading all the necessary data, the module proceeds to prepare the necessary objects and parameters for the simulation (see 'Data dependencies' below).
Depending on the objects, some are parameterized using empirical models, others based on literature (e.g. longevity values for western boreal species taken from Burton & Cumming (1995) - see `?LandR::speciesTableUpdate`), or expert knowledge (e.g., `sufficientLight` values adjusted to reflect western boreal forest succession dynamics)

## Filling data gaps

* mismatches between stand age, stand biomass and species cover are dealt with by trusting species % cover first.
  If `cover > 0` and `age == 0`, `age` is empirically estimated using a linear mixed effects model:

    `age ~ B * species + (1 | initialEcoregionCode) + cover`

  If `cover == 0`, `age == 0` and `biomass > 0`, `biomass` is set to `0`.

* species `longevity` parameters are taken from published numbers from closest regions (Burton & Cumming 1995)

* the user can choose to replace certain land cover classes with others (parameter `LCCClassesToReplaceNN`). For example, in a "Natural Range of Variation" project, urban pixels can be changed to forested. Since the currently available simulation modules do not drive land cover change, species-ecoregion traits will be spatially non-varying. This means that initial land cover classes that are "transient", such as "recent burn" are likely not appropriate to have "permanent" traits associated with them. This module offers the ability to estimate the parameters for these pixels *as if they were a neighbouring land cover class*. In these two cases, the module can replace these classes with a neighbouring forest type (defined by the parameter `forestedLCCClasses` and probabilistically chosen in proportion to its neighbourhood abundance up to a radius of 5 times the pixel resolution).


## Parameterization

LandR-Biomass, like LBSE, has species-level traits (invariant species tratis) and species-ecolocation level traits (spatially varying traits). Ecolocations are defined, by default, as *land cover class* X *ecodistrict* (Canadian, federal definition) combinations, and the traits are estimated by *species* X *ecolocation* combinations. This can mean that there are some species-ecolocation traits that are unique at the pixel level as there may be rare combinations of, say, a land cover type, for a given species, in a given ecodistrict. 
**Note that `ecolocations` are called `ecoregionGroup`'s across LandR Biomass objects, and species `speciesCode`**. For simplicity, below we refer to these as "ecolocation" and "species", but bear in mind that when passing formulas to the modules LandR object nomenclature will need to be used. 

### Spatially varying species traits

* establishment probabilities: species establishment probabilities (or sometimes `SEP` in LANDIS) by ecolocation are empirically estimated using species cover data (converted to presence/absence) using a GLMEM defined as (the equation is a parameter in the module that can be changed by the user):
  + `prob. presence ~ species + (1|ecolocation)`

* `maxB` is estimated empirically, using stand age, stand biomass per species, per ecolocation data, using an LMEM. Because the following equation represents a curve whose positive slope is decreasing with age (via `log(age)`), we estimate `maxB` as the expected `B` when `cover = 100` and `logAge = log(longevity)` for a given species in a given `ecolocation`. This equation is a parameter in the module that can be changed by the user.
  + `B ~ logAge * species + cover * species + (logAge + cover + species | ecolocation)`

* `maxANPP`: is defined as maxB/30 following LANDIS-II. But see below for updates.

All empirically estimated parameters *can* be estimated using data from a larger study area (`studyAreaLarge`) than the one used to run the simulation (`studyArea`), if the user provides such a polygon.

### Invariant species traits:

*  `growthcurve` and `mortalityshape` are by default taken from LANDIS-II parameters. However, they can be estimated from data by using the `Biomass_speciesParameters` module (see below for a brief explanation).

#### Updating species growth/mortality traits `Biomass_speciesParameters`
Briefly:
1.	We run ~41,000,000 hypothetical species with full factorial combinations of longevity, ratio of `maxANPP` to `maxBiomass`, `growthcurve`, `mortalityshape`

2.	We take the closest permanent and temporary sample plots (PSP) in or near the study area and find the hypothetical species in previous step that most closely matches the growth dynamics in the PSPs. This gives us the `growthcurve`, `mortalityshape`, and ratio of maximum biomass (`maxB`) to maximum ANPP (`maxANPP`) for each species in our study area

3.	We introduce a new parameter, `actualMaxBiomass`. We recognize that `maxB`, as obtained empirically above, cannot be easily reached in simulations because all reasonable values of `growthcurve`, `mortalityshape` and `longevity` prevent the equation from reaching `maxB` (it acts as an asymptote that is never approached). The `actualMaxBiomass` is then obtained by multiplying the empirically estimated `maxB` by the ratio between the `maxBiomass` parameter used for the simulations in step 1 and the maximum simulated biomass *actually* achieved in the simulations (of step 1).  We use this `actualMaxBiomass` so that the resulting non-linear growth curves will hit the the empirically estimated `maxB`. This adjustment effectively allows the growth equation's "maximum biomass" parameter to actually be the empirically estimated maximum biomass.  

4.	Species-specific `maxANPP` is estimated by multiplying the empirically estimated `maxB` (spatial) above and the ratio of the simulated `maxANPP` parameter (point 1) to the maximum simulated biomass (step 1) at the species level. 

## Get the module

See [SpaDES-modules repository](https://github.com/PredictiveEcology/SpaDES-modules) to see how to download this and other SpaDES modules.
Alternatively, it can be forked or cloned from github.com directly.

# Load libraries

```{r load-libraries}
library(magrittr) # for %>% pipe
library(SpaDES)
```

# Set up paths
```{r module_usage}
moduleName <- "Biomass_borealDataPrep"
spadesModulesDirectory <- ".." # where the module will be located -- this is correct, if this module
                               # is an Rstudio project, i.e., one up from the project

inputPath <- file.path(dirname(spadesModulesDirectory), "inputs") %>% checkPath(create = TRUE)
outputPath <- file.path(dirname(spadesModulesDirectory), "outputs") 
cachePath = file.path(outputPath, "cache")
         
setPaths(cachePath = cachePath,
         modulePath = spadesModulesDirectory,
         inputPath = inputPath,
         outputPath = outputPath)
paths <- getPaths()
```

# Choose a study area

```{r get-study-area}
library(raster)
# modulePath <- Cache(readline, paste0("Where is the module path? (e.g., ~/module, with no quotes).\n",
#                                      "Press Enter to accept the path in getPaths()$modulePath: "),
#                     cacheRepo = cachePath)
# setPaths(cachePath = cachePath, modulePath = modulePath)

## do you want to hand-draw a map or use defaults?
# - note that large areas will take longer to compute
handDrawMap <- FALSE

if (handDrawMap) {
  dev()
  clearPlot()
  canadaMap <- Cache(getData, 'GADM', country = 'CAN', level = 1, path = Paths$inputPath,
                     cacheRepo = getPaths()$cachePath, quick = FALSE)
  Plot(canadaMap, speedup = 5, visualSqueeze = 0.9) # 5 seemed optimal
  
  ## hand-drawn study area
  if (!exists("studyAreaLarge")) {
    message("Since there is no object called 'studyAreaLarge', please draw a study area with 10 points")
    severalrandompoints <- Cache(clickCoordinates, 10)
    # if(startsWith(attr(severalrandompoints, "tags"), "cache")) message("Taking studyAreaLarge from Cache")
    studyAreaLarge <- SpatialPolygons(list(Polygons(list(Polygon(severalrandompoints$coords)), ID = 1)),
                                          proj4string = crs(canadaMap))
  }
  Plot(studyAreaLarge, addTo = "canadaMap", col = "red")
  studyArea <- raster::buffer(studyAreaLarge, buffer = -200) ## make a smaller area within the first
} else {
  studyAreaLarge <- Cache(randomStudyArea, size = 1e8)
  studyArea <- raster::buffer(studyAreaLarge, buffer = -200)   ## make a smaller area within the first
}

times <- list(start = 0, end = 10)
modules <- list("Biomass_borealDataPrep")
objects <- list("studyAreaLarge" = studyAreaLarge,
                "studyArea" = studyArea) 

mySim <- simInit(times = times, #params = parameters, 
                 modules = modules, #, "Biomass_core"),
                 objects = objects, paths = getPaths())
```

# Run `spades`

This module is about data preparation, so there is no stochastic elements.
The `spades` call will only cause one event to occur (the `init` event)

```{r run-spades}
simOut <- spades(mySim, debug = TRUE)
```

# Visualize

The `Plot` function will visualize all known .quickPlot type objects, which includes `Raster*` and `SpatialPolygons*` objects.
After running this module, these are the outputs, which would likely be used as inputs to `Biomass_core`.

```{r visualize}
dev()
clearPlot()

Plot(simOut)
```

# Downloads

During the `simInit` call, if the user does not provide alternatives for the expected inputs, the module will download 3 large `.tar` files (~2 GB each) and 1 `.zip` file (~45 MB) from the internet.

# Data dependencies

**NOTE:** all raster _inputs_ should be at the scale of `rasterToMatchLarge`/`studyAreaLarge` and all raster _outputs_ will be at the scale of `rasterToMatch`/`studyArea.`

## Module parameters

```{r moduleParams, echo = FALSE, eval = TRUE}
df_params <- SpaDES.core::moduleParams("Biomass_borealDataPrep", "..")
knitr::kable(df_params)
```

## Inputs

This module has several input requirements. 
One is a study area, which should be provided as a `SpatialPolygonsDataFrame`, and named `studyAreaLarge`.
This should be inside the boundaries of the boreal forest of Canada. 
When first running the code in this `.Rmd` file, you will be prompted to draw a polygon if none is provided as an input.

```{r moduleInputs, echo = FALSE, eval = TRUE}
df_inputs <- SpaDES.core::moduleInputs("Biomass_borealDataPrep", "..")
knitr::kable(df_inputs)
```

### Creates Inputs

Most of the inputs will be created automatically, if they are not provided by the user. 
The automatic creation will work for western boreal forests of Canada.
These are zip files and tar files that are available from various Natural Resources Canada web pages. 

## Outputs

This will show the outputs of this module, which can be used directly as the inputs for Biomass_core:

```{r moduleOutputs, echo = FALSE, eval = TRUE}
df_outputs <- SpaDES.core::moduleOutputs("Biomass_borealDataPrep", "..")
knitr::kable(df_outputs)
```

```{r outputs2}
## species table
simOut$speciesTable
```

```{r outputs3}
Plot(simOut$biomassMap)
simOut$studyAreaLarge <- spTransform(simOut$studyAreaLarge, crs(simOut$biomassMap))
Plot(simOut$studyAreaLarge, addTo = "simOut$biomassMap")
```

## Getting help

- <https://gitter.im/PredictiveEcology/LandR_Biomass>
